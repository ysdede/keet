async function Ue({backend:a="webgpu",wasmPaths:e,numThreads:s}={}){let t;try{const n=await import("./ort.bundle.min-DbFDO68X.js");t=n.default||n,console.log("[Parakeet.js] ORT structure:",{hasDefault:!!n.default,hasEnv:!!t.env,hasWasm:!!t.env?.wasm,hasWebgpu:!!t.env?.webgpu,keys:Object.keys(t).slice(0,10)}),t.env||(console.log("[Parakeet.js] Trying alternative access patterns..."),console.log("[Parakeet.js] ortModule keys:",Object.keys(n)),n.ort&&(t=n.ort,console.log("[Parakeet.js] Found ort in ortModule.ort")))}catch(n){throw console.error("[Parakeet.js] Failed to import onnxruntime-web:",n),new Error("Failed to load ONNX Runtime Web. Please check your network connection.")}if(!t||!t.env)throw new Error("ONNX Runtime Web loaded but env is not available. This might be a bundling issue.");if(!t.env.wasm.wasmPaths){const o=t.env.versions?.common||"1.22.0-dev.20250409-89f8206ba4";t.env.versions?.common||console.warn("Parakeet.js: Could not auto-detect onnxruntime-web version. Using fallback version; set ort.env.wasm.wasmPaths manually for best results."),t.env.wasm.wasmPaths=`https://cdn.jsdelivr.net/npm/onnxruntime-web@${o}/dist/`}if((a==="wasm"||a==="webgpu")&&(typeof SharedArrayBuffer<"u"?(t.env.wasm.numThreads=s||navigator.hardwareConcurrency||4,t.env.wasm.simd=!0,console.log(`[Parakeet.js] WASM configured with ${t.env.wasm.numThreads} threads, SIMD enabled`)):(console.warn("[Parakeet.js] SharedArrayBuffer not available - using single-threaded WASM"),t.env.wasm.numThreads=1),t.env.wasm.proxy=!1),a==="webgpu"){const n="gpu"in navigator;if(console.log(`[Parakeet.js] WebGPU supported: ${n}`),n)try{console.log("[Parakeet.js] WebGPU will be initialized automatically when creating session")}catch(o){console.warn("[Parakeet.js] WebGPU initialization failed:",o),console.warn("[Parakeet.js] Falling back to WASM"),a="wasm"}else console.warn("[Parakeet.js] WebGPU not supported – falling back to WASM"),a="wasm"}return typeof globalThis<"u"&&(globalThis.ort=t),t}async function Ye(a){const e=await fetch(a);if(!e.ok)throw new Error(`Failed to fetch ${a}: ${e.status}`);return e.text()}class je{constructor(e){this.id2token=e,this.blankToken="<blk>",this.blankId=e.findIndex(s=>s==="<blk>"),this.blankId===-1&&(console.warn("[ParakeetTokenizer] Blank token <blk> not found in vocabulary, defaulting to 1024"),this.blankId=1024),this.sanitizedTokens=this.id2token.map(s=>s&&s.replace(/\u2581/g," "))}static async fromUrl(e){const t=(await Ye(e)).split(/\r?\n/).filter(Boolean),n=[];for(const o of t){const[r,i]=o.split(/\s+/),h=parseInt(i,10);n[h]=r}return new je(n)}decode(e){const s=[];for(const n of e){if(n===this.blankId)continue;const o=this.sanitizedTokens[n];o!==void 0&&s.push(o)}let t=s.join("");return t=t.replace(/^\s+/,""),t=t.replace(/\s+(?=[^\w\s])/g,""),t=t.replace(/\s+/g," "),t.trim()}}class Ze{constructor(e,s={}){this.modelUrl=e,this.opts=s,this.opts.enableGraphCapture===void 0&&(this.opts.enableGraphCapture=this.opts.backend==="wasm"),this.session=null,this.ort=null}async _ensureSession(){if(!this.session){this.ort=await Ue(this.opts);const e=this.opts.enableGraphCapture?{enableProfiling:this.opts.enableProfiling||!1,enableGraphCapture:!0}:{enableProfiling:this.opts.enableProfiling||!1},s=async()=>{try{return await this.ort.InferenceSession.create(this.modelUrl,e)}catch(t){const n=(t.message||"")+"";if(e.enableGraphCapture&&n.includes("graph capture"))return console.warn("[Preprocessor] Graph capture unsupported, retrying without it"),await this.ort.InferenceSession.create(this.modelUrl,{...e,enableGraphCapture:!1});throw t}};this.session=await s()}}async process(e){await this._ensureSession();let s;e instanceof Float32Array?s=e.byteOffset===0||e.byteLength===e.length*4?e:new Float32Array(e):s=new Float32Array(e);const t=new this.ort.Tensor("float32",s,[1,s.length]),n=new BigInt64Array([BigInt(s.length)]),o=new this.ort.Tensor("int64",n,[1]),r={waveforms:t,waveforms_lens:o},i=await this.session.run(r),h=i.features,d=i.features_lens;return{features:h.data,length:Number(d.data[0])}}}const ze=16e3,R=512,Te=400,ue=160,Re=.97,We=2**-24,W=(R>>1)+1,Ae=200/3,Fe=1e3,$e=Fe/Ae,Ge=Math.log(6.4)/27;function Ne(a){return a>=Fe?$e+Math.log(a/Fe)/Ge:a/Ae}function et(a){return a>=$e?Fe*Math.exp(Ge*(a-$e)):a*Ae}function tt(a){const s=ze/2,t=new Float64Array(W);for(let l=0;l<W;l++)t[l]=s*l/(W-1);const n=Ne(0),o=Ne(s),r=a+2,i=new Float64Array(r);for(let l=0;l<r;l++)i[l]=et(n+(o-n)*l/(r-1));const h=new Float64Array(r-1);for(let l=0;l<r-1;l++)h[l]=i[l+1]-i[l];const d=new Float32Array(a*W);for(let l=0;l<a;l++){const f=2/(i[l+2]-i[l]),u=l*W;for(let c=0;c<W;c++){const p=(t[c]-i[l])/h[l],g=(i[l+2]-t[c])/h[l+1];d[u+c]=Math.max(0,Math.min(p,g))*f}}return d}function st(){const a=new Float64Array(R),e=R-Te>>1;for(let s=0;s<Te;s++)a[e+s]=.5*(1-Math.cos(2*Math.PI*s/(Te-1)));return a}function nt(a){const e=a>>1,s=new Float64Array(e),t=new Float64Array(e);for(let n=0;n<e;n++){const o=-2*Math.PI*n/a;s[n]=Math.cos(o),t[n]=Math.sin(o)}return{cos:s,sin:t}}function ot(a,e,s,t){let n=0;for(let o=0;o<s-1;o++){if(o<n){let i=a[o];a[o]=a[n],a[n]=i,i=e[o],e[o]=e[n],e[n]=i}let r=s>>1;for(;r<=n;)n-=r,r>>=1;n+=r}for(let o=2;o<=s;o<<=1){const r=o>>1,i=s/o;for(let h=0;h<s;h+=o)for(let d=0;d<r;d++){const l=d*i,f=t.cos[l],u=t.sin[l],c=h+d,p=c+r,g=a[p]*f-e[p]*u,b=a[p]*u+e[p]*f;a[p]=a[c]-g,e[p]=e[c]-b,a[c]+=g,e[c]+=b}}}class ie{constructor(e={}){this.nMels=e.nMels||128,this.melFilterbank=tt(this.nMels),this.hannWindow=st(),this.twiddles=nt(R),this._fftRe=new Float64Array(R),this._fftIm=new Float64Array(R),this._powerBuf=new Float32Array(W)}process(e){const{rawMel:s,nFrames:t,featuresLen:n}=this.computeRawMel(e);return n===0?{features:new Float32Array(0),length:0}:{features:this.normalizeFeatures(s,t,n),length:n}}computeRawMel(e,s=0){const t=e.length;if(t===0)return{rawMel:new Float32Array(0),nFrames:0,featuresLen:0};const n=new Float32Array(t);n[0]=e[0];for(let k=1;k<t;k++)n[k]=e[k]-Re*e[k-1];const o=R>>1,r=t+2*o,i=new Float64Array(r);for(let k=0;k<t;k++)i[o+k]=n[k];const h=Math.floor((r-R)/ue)+1,d=Math.floor(t/ue);if(d===0)return{rawMel:new Float32Array(0),nFrames:0,featuresLen:0};const l=new Float32Array(this.nMels*h),f=this._fftRe,u=this._fftIm,c=this._powerBuf,p=this.hannWindow,g=this.melFilterbank,b=this.nMels,T=this.twiddles;for(let k=s;k<h;k++){const S=k*ue;for(let w=0;w<R;w++)f[w]=i[S+w]*p[w],u[w]=0;ot(f,u,R,T);for(let w=0;w<W;w++)c[w]=f[w]*f[w]+u[w]*u[w];for(let w=0;w<b;w++){let F=0;const C=w*W;for(let y=0;y<W;y++)F+=c[y]*g[C+y];l[w*h+k]=Math.log(F+We)}}return{rawMel:l,nFrames:h,featuresLen:d}}normalizeFeatures(e,s,t){const n=this.nMels,o=new Float32Array(n*t);for(let r=0;r<n;r++){const i=r*s,h=r*t;let d=0;for(let c=0;c<t;c++)d+=e[i+c];const l=d/t;let f=0;for(let c=0;c<t;c++){const p=e[i+c]-l;f+=p*p}const u=t>1?1/(Math.sqrt(f/(t-1))+1e-5):0;for(let c=0;c<t;c++)o[h+c]=(e[i+c]-l)*u}return o}}class Ee{constructor(e={}){this.preprocessor=new ie({nMels:e.nMels||128}),this.nMels=this.preprocessor.nMels,this.boundaryFrames=e.boundaryFrames||3,this._cachedRawMel=null,this._cachedNFrames=0,this._cachedAudioLen=0,this._cachedFeaturesLen=0}reset(){this._cachedRawMel=null,this._cachedNFrames=0,this._cachedAudioLen=0,this._cachedFeaturesLen=0}process(e,s=0){const t=e.length;if(t===0)return{features:new Float32Array(0),length:0,cached:!1,cachedFrames:0,newFrames:0};if(!(s>0&&this._cachedRawMel!==null&&s<=this._cachedAudioLen)){const{rawMel:f,nFrames:u,featuresLen:c}=this.preprocessor.computeRawMel(e),p=this.preprocessor.normalizeFeatures(f,u,c);return this._cachedRawMel=f,this._cachedNFrames=u,this._cachedAudioLen=t,this._cachedFeaturesLen=c,{features:p,length:c,cached:!1,cachedFrames:0,newFrames:c}}const o=Math.floor(s/ue),r=Math.max(0,Math.min(o-this.boundaryFrames,this._cachedFeaturesLen)),{rawMel:i,nFrames:h,featuresLen:d}=this.preprocessor.computeRawMel(e,r);if(r>0&&this._cachedRawMel)for(let f=0;f<this.nMels;f++){const u=f*this._cachedNFrames,c=f*h;for(let p=0;p<r;p++)i[c+p]=this._cachedRawMel[u+p]}const l=this.preprocessor.normalizeFeatures(i,h,d);return this._cachedRawMel=i,this._cachedNFrames=h,this._cachedAudioLen=t,this._cachedFeaturesLen=d,{features:l,length:d,cached:!0,cachedFrames:r,newFrames:d-r}}clear(){this.reset()}}const ft={SAMPLE_RATE:ze,N_FFT:R,WIN_LENGTH:Te,HOP_LENGTH:ue,PREEMPH:Re,LOG_ZERO_GUARD:We,N_FREQ_BINS:W};class ye{constructor({tokenizer:e,encoderSession:s,joinerSession:t,preprocessor:n,ort:o,subsampling:r=8,windowStride:i=.01,normalizer:h=u=>u,onnxPreprocessor:d=null,nMels:l,maxIncrementalCacheSize:f=50}){this.tokenizer=e,this.encoderSession=s,this.joinerSession=t,this.preprocessor=n,this.ort=o,this._onnxPreprocessor=d,this._jsPreprocessor=n instanceof ie?n:null,this._incrementalMel=n instanceof ie?new Ee({nMels:n.nMels}):null,this.blankId=e.blankId,this.predHidden=640,this.predLayers=2,this.maxTokensPerStep=10;const u=this.predLayers,c=this.predHidden,p=u*1*c,g=new Float32Array(p);this._combState1=new o.Tensor("float32",g,[u,1,c]),this._combState2=new o.Tensor("float32",g.slice(),[u,1,c]),this._normalizer=h,this.subsampling=r,this.windowStride=i,this._nMels=l||128,this._targetIdArray=new Int32Array(1),this._targetTensor=new o.Tensor("int32",this._targetIdArray,[1,1]),this._targetLenArray=new Int32Array([1]),this._targetLenTensor=new o.Tensor("int32",this._targetLenArray,[1]),this._encoderFrameBuffer=null,this._encoderFrameTensor=null,this._incrementalCache=new Map,this.maxIncrementalCacheSize=f}static async fromUrls(e){const{encoderUrl:s,decoderUrl:t,tokenizerUrl:n,preprocessorUrl:o,encoderDataUrl:r,decoderDataUrl:i,filenames:h,backend:d="webgpu-hybrid",wasmPaths:l,subsampling:f=8,windowStride:u=.01,verbose:c=!1,enableProfiling:p=!1,enableGraphCapture:g,cpuThreads:b=void 0,preprocessorBackend:T="js",nMels:k}=e,S=T==="js";if(console.log(`[Parakeet.js] Preprocessor backend requested: '${T}' → ${S?"JS (mel.js)":"ONNX"}`),!s||!t||!n||!o&&!S)throw new Error('fromUrls requires encoderUrl, decoderUrl, tokenizerUrl and preprocessorUrl (preprocessorUrl not needed if preprocessorBackend="js")');let w=d;d.startsWith("webgpu")&&(w="webgpu");const F=await Ue({backend:w,wasmPaths:l,numThreads:b}),y={executionProviders:[],graphOptimizationLevel:"all",executionMode:"parallel",enableCpuMemArena:!0,enableMemPattern:!0,enableProfiling:p,enableGraphCapture:!!g&&d==="webgpu-strict",logSeverityLevel:c?0:2};d==="webgpu-hybrid"?y.executionProviders=[{name:"webgpu",deviceType:"gpu",powerPreference:"high-performance"},"wasm"]:d==="webgpu-strict"?y.executionProviders=[{name:"webgpu",deviceType:"gpu",powerPreference:"high-performance"}]:d==="wasm"&&(y.executionProviders=["wasm"]),console.log(`[Parakeet.js] Creating ONNX sessions with execution mode '${d}'. Providers:`,y.executionProviders),c&&console.log("[Parakeet.js] Verbose logging enabled for ONNX Runtime.");const X={...y};r&&h?.encoder&&(X.externalData=[{data:r,path:h.encoder+".data"}]);const G={...y};i&&h?.decoder&&(G.externalData=[{data:i,path:h.decoder+".data"}]),d.startsWith("webgpu")&&(G.executionProviders=["wasm"]);async function B(I,Q){try{return await F.InferenceSession.create(I,Q)}catch(N){const pe=(N.message||"")+"";if(Q.enableGraphCapture&&pe.includes("graph capture")){console.warn("[Parakeet] Graph-capture unsupported for this model/backend; retrying without it");const de={...Q,enableGraphCapture:!1};return await F.InferenceSession.create(I,de)}throw N}}const O=je.fromUrl(n),D=k||128,v=new ie({nMels:D});let q=null;!S&&o?(q=new Ze(o,{backend:"wasm",wasmPaths:l,enableProfiling:p,enableGraphCapture:!1,numThreads:b}),console.log(`[Parakeet.js] ONNX preprocessor session created (${D} mel bins)`)):!S&&!o&&console.warn("[Parakeet.js] ONNX preprocessor requested but no URL provided — falling back to JS");const se=S?v:q||v,J=Promise.resolve(se);console.log(`[Parakeet.js] Active preprocessor: ${(se===v?"js":"onnx")==="js"?"JS (mel.js) — no ONNX preprocessor needed":"ONNX (nemo128.onnx)"}, ${D} mel bins`);let le,Z;d==="webgpu-hybrid"?(le=await B(s,X),Z=await B(t,G)):[le,Z]=await Promise.all([B(s,X),B(t,G)]);const[j,P]=await Promise.all([O,J]);try{const I=new Float32Array(1600);await P.process(I),c&&console.log("[Parakeet.js] Preprocessor warmed up")}catch(I){console.warn("[Parakeet.js] Preprocessor warm-up failed (non-fatal):",I.message)}return new ye({tokenizer:j,encoderSession:le,joinerSession:Z,preprocessor:P,ort:F,subsampling:f,windowStride:u,onnxPreprocessor:q!==P?q:null,nMels:D})}async _runCombinedStep(e,s,t=null){const n=typeof s=="number"?s:this.blankId;this._targetIdArray[0]=n;const o=t?.state1||this._combState1,r=t?.state2||this._combState2,i={encoder_outputs:e,targets:this._targetTensor,target_length:this._targetLenTensor,input_states_1:o,input_states_2:r},h=await this.joinerSession.run(i),d=h.outputs,l=this.tokenizer.id2token.length,f=d.dims[3],u=d.data,c=u.subarray(0,l),p=u.subarray(l,f);let g=0;if(p.length){let T=-1/0;for(let k=0;k<p.length;++k)p[k]>T&&(T=p[k],g=k)}const b={state1:h.output_states_1||o,state2:h.output_states_2||r};return{tokenLogits:c,step:g,newState:b,_logitsTensor:d}}_snapshotDecoderState(e){if(!e)return null;const s=e.state1,t=e.state2;return{s1:new Float32Array(s.data),s2:new Float32Array(t.data),dims1:s.dims.slice(),dims2:t.dims.slice()}}_restoreDecoderState(e){if(!e)return null;const s=new this.ort.Tensor("float32",new Float32Array(e.s1),e.dims1),t=new this.ort.Tensor("float32",new Float32Array(e.s2),e.dims2);return{state1:s,state2:t}}async computeFeatures(e,s=16e3,t={}){const{prefixSamples:n=0}=t;if(this._incrementalMel&&n>0){const h=this._incrementalMel.process(e,n),d=h.length;return{features:h.features,T:d,melBins:this._nMels,cached:h.cached,cachedFrames:h.cachedFrames,newFrames:h.newFrames}}const{features:o,length:r}=await this.preprocessor.process(e),i=o.length/this._nMels;return{features:o,T:i,melBins:this._nMels,validLength:r}}setPreprocessorBackend(e){if(e==="onnx"){if(!this._onnxPreprocessor)throw new Error("ONNX preprocessor not available. Load model with preprocessorUrl to enable ONNX backend.");this.preprocessor=this._onnxPreprocessor,this._incrementalMel=null,console.log("[Parakeet.js] Switched to ONNX preprocessor")}else if(e==="js")this._jsPreprocessor||(this._jsPreprocessor=new ie({nMels:128})),this.preprocessor=this._jsPreprocessor,this._incrementalMel=new Ee({nMels:this._jsPreprocessor.nMels}),console.log("[Parakeet.js] Switched to JS preprocessor (incremental caching enabled)");else throw new Error(`Unknown preprocessor backend: ${e}. Use 'js' or 'onnx'.`)}getPreprocessorBackend(){return this.preprocessor instanceof ie?"js":"onnx"}resetMelCache(){this._incrementalMel&&this._incrementalMel.reset()}clearIncrementalCache(){this._incrementalCache.clear()}_disposeDecoderState(e,s=null){e&&(e.state1&&e.state1!==this._combState1&&e.state1!==s?.state1&&e.state1.dispose?.(),e.state2&&e.state2!==this._combState2&&e.state2!==s?.state2&&e.state2.dispose?.())}getFrameTimeStride(){return this.subsampling*this.windowStride}frameToTime(e,s=0){return s+e*this.getFrameTimeStride()}getStreamingConstants(){return{subsampling:this.subsampling,windowStride:this.windowStride,frameTimeStride:this.getFrameTimeStride(),melBins:80,blankId:this.blankId,maxTokensPerStep:this.maxTokensPerStep}}async transcribe(e,s=16e3,t={}){const{returnTimestamps:n=!1,returnConfidences:o=!1,temperature:r=1,debug:i=!1,enableProfiling:h=!0,skipCMVN:d=!1,frameStride:l=1,previousDecoderState:f=null,returnDecoderState:u=!1,timeOffset:c=0,returnTokenIds:p=!1,returnFrameIndices:g=!1,returnLogProbs:b=!1,returnTdtSteps:T=!1,prefixSamples:k=0,precomputedFeatures:S=null}=t,w=i||h;let F,C=0,y=0,X=0,G=0;w&&(F=performance.now());let B,O,D,v,q,se=S?"mel-worker":this.getPreprocessorBackend();if(S)B=S.features,O=S.T,D=S.melBins,v={},console.log(`[Parakeet] Preprocessor: mel-worker (precomputed ${O} frames × ${D} mel bins, 0 ms)`);else if(w){const m=performance.now();({features:B,T:O,melBins:D,validLength:q,...v}=await this.computeFeatures(e,s,{prefixSamples:k})),C=performance.now()-m;const _=v?.cached?` (cached: ${v.cachedFrames} frames, new: ${v.newFrames} frames)`:"";console.log(`[Parakeet] Preprocessor: ${se}, ${O} frames × ${D} mel bins, ${C.toFixed(1)} ms${_}`)}else({features:B,T:O,melBins:D,validLength:q,...v}=await this.computeFeatures(e,s,{prefixSamples:k}));if(!B||!B.length||O<=0||D<=0)return{utterance_text:"",words:[],tokens:[],confidence_scores:{overall_log_prob:null,frame:null,frame_avg:null},metrics:w?{preprocess_ms:+C.toFixed(1),encode_ms:0,decode_ms:0,tokenize_ms:0,total_ms:+(performance.now()-F).toFixed(1),rtf:0}:null,is_final:!t?.incremental};const J=e?e.length/s:O*160/s,me=new this.ort.Tensor("float32",B,[1,D,O]),le=q??O,Z=new this.ort.Tensor("int64",BigInt64Array.from([BigInt(le)]),[1]);let j;if(w){const m=performance.now(),_=await this.encoderSession.run({audio_signal:me,length:Z});y=performance.now()-m,j=_.outputs??Object.values(_)[0]}else{const m=await this.encoderSession.run({audio_signal:me,length:Z});j=m.outputs??Object.values(m)[0]}me.dispose?.(),Z.dispose?.();const[,P,I]=j.dims;let Q;if(j.dims.length===3&&j.dims[0]===1&&j.dims[1]===P&&j.dims[2]===I){Q=new Float32Array(I*P);const m=j.data,_=Math.min(64,P);for(let x=0;x<P;x+=_){const L=Math.min(x+_,P);for(let $=0;$<I;$++){const U=$*P;for(let H=x;H<L;H++)Q[U+H]=m[H*I+$]}}}else console.warn("[Parakeet] Unexpected encoder output format:",j.dims),Q=new Float32Array(j.data);j.dispose?.(),(!this._encoderFrameBuffer||this._encoderFrameBuffer.length!==P)&&(this._encoderFrameBuffer=new Float32Array(P),this._encoderFrameTensor=new this.ort.Tensor("float32",this._encoderFrameBuffer,[1,P,1]));const N=[],pe=[],de=[],he=[];let Le=0;const xe=[],Se=[],Pe=[],ge=this.subsampling*this.windowStride;let Me=0,ve=c,E=null;f&&(E=this._restoreDecoderState(f),i&&console.log("[Parakeet] Restored decoder state from previous chunk"));let K=0;const A=t.incremental;if(A&&A.cacheKey){K=Math.max(0,Math.min(I,Math.floor(((A.prefixSeconds||0)+1e-6)/ge)));const m=this._incrementalCache.get(A.cacheKey);m&&m.prefixFrames===K&&m.D===P&&(Me=K,ve=c+K*ge,E=this._restoreDecoderState(m.state),i&&console.log(`[Parakeet] Incremental cache hit: skipping ${K}/${I} frames (${(K/I*100).toFixed(0)}%)`),this._incrementalCache.delete(A.cacheKey),this._incrementalCache.set(A.cacheKey,m))}let we=0;const Ve=w?performance.now():0;let De=Me>0||K===0;for(let m=Me;m<I;){const _=m*P;for(let M=0;M<P;M++)this._encoderFrameBuffer[M]=Q[_+M];const x=N.length?N[N.length-1]:this.blankId,{tokenLogits:L,step:$,newState:U,_logitsTensor:H}=await this._runCombinedStep(this._encoderFrameTensor,x,E);let V=-1/0,te=0;for(let M=0;M<L.length;M++){const z=L[M]/r;z>V&&(V=z,te=M)}let re=1,be=0;if(o||b){let M=0;for(let z=0;z<L.length;z++)M+=Math.exp(L[z]/r-V);re=1/M,be=L[te]/r-V-Math.log(M),o&&(he.push(re),Le+=Math.log(re))}if(H?.dispose?.(),te!==this.blankId){if(this._disposeDecoderState(E,U),E=U,N.push(te),g&&xe.push(m),b&&Se.push(be),T&&Pe.push($),n){const M=$>0?$:1,z=ve+m*ge,Qe=ve+(m+M)*ge;pe.push([z,Qe])}o&&de.push(re),we+=1}else this._disposeDecoderState(U,E);if($>0?(m+=$,we=0):(te===this.blankId||we>=this.maxTokensPerStep)&&(m+=l,we=0),A&&A.cacheKey&&!De&&m>=K){const M=this._snapshotDecoderState(E);if(!this._incrementalCache.has(A.cacheKey)&&this._incrementalCache.size>=this.maxIncrementalCacheSize){const z=this._incrementalCache.keys().next().value;i&&console.log(`[Parakeet] Incremental cache full (${this.maxIncrementalCacheSize}); evicting oldest entry: ${z}`),this._incrementalCache.delete(z)}this._incrementalCache.has(A.cacheKey)&&this._incrementalCache.delete(A.cacheKey),this._incrementalCache.set(A.cacheKey,{state:M,prefixFrames:K,D:P}),De=!0}}w&&(X=performance.now()-Ve);let Be;w&&(Be=performance.now());const Oe=this._normalizer(this.tokenizer.decode(N));if(w&&(G=performance.now()-Be),!n&&!o){if(w){const x=performance.now()-F,L=J/(x/1e3);console.log(`[Perf] RTF: ${L.toFixed(2)}x (audio ${J.toFixed(2)} s, time ${(x/1e3).toFixed(2)} s)`),console.table({Preprocess:`${C.toFixed(1)} ms`,Encode:`${y.toFixed(1)} ms`,Decode:`${X.toFixed(1)} ms`,Tokenize:`${G.toFixed(1)} ms`,Total:`${x.toFixed(1)} ms`})}const m=w?{preprocess_ms:+C.toFixed(1),encode_ms:+y.toFixed(1),decode_ms:+X.toFixed(1),tokenize_ms:+G.toFixed(1),total_ms:+(performance.now()-F).toFixed(1),rtf:+(J/((performance.now()-F)/1e3)).toFixed(2),preprocessor_backend:se,mel_cache:v?.cached?{cached_frames:v.cachedFrames,new_frames:v.newFrames}:null}:null,_={utterance_text:Oe,words:[],metrics:m,is_final:!f};return u&&(_.decoderState=this._snapshotDecoderState(E)),p&&(_.tokenIds=N.slice()),g&&(_.frameIndices=xe.slice()),b&&(_.logProbs=Se.slice()),T&&(_.tdtSteps=Pe.slice()),this._disposeDecoderState(E),_}const ee=[],fe=[];let ne="",Ie=0,ke=0,Y=[];if(N.forEach((m,_)=>{const x=this.tokenizer.id2token[m];if(x===this.tokenizer.blankToken)return;const L=x.startsWith("▁"),$=L?x.slice(1):x,U=pe[_]||[null,null],H=de[_],V={token:$,raw_token:x,is_word_start:L};if(n&&(V.start_time=+U[0].toFixed(3),V.end_time=+U[1].toFixed(3)),o&&(V.confidence=+H.toFixed(4)),fe.push(V),L){if(ne){const te=Y.length?Y.reduce((re,be)=>re+be,0)/Y.length:0;ee.push({text:ne,start_time:+Ie.toFixed(3),end_time:+ke.toFixed(3),confidence:+te.toFixed(4)})}ne=$,n&&(Ie=U[0],ke=U[1]),Y=o?[H]:[]}else ne+=$,n&&(ke=U[1]),o&&Y.push(H)}),ne){const m=Y.length?Y.reduce((_,x)=>_+x,0)/Y.length:0;ee.push({text:ne,start_time:+Ie.toFixed(3),end_time:+ke.toFixed(3),confidence:+m.toFixed(4)})}const qe=ee.length&&o?ee.reduce((m,_)=>m+_.confidence,0)/ee.length:null,Je=fe.length&&o?fe.reduce((m,_)=>m+(_.confidence||0),0)/fe.length:null;if(w){const m=performance.now()-F,_=J/(m/1e3);console.log(`[Perf] RTF: ${_.toFixed(2)}x (audio ${J.toFixed(2)} s, time ${(m/1e3).toFixed(2)} s)`),console.table({Preprocess:`${C.toFixed(1)} ms`,Encode:`${y.toFixed(1)} ms`,Decode:`${X.toFixed(1)} ms`,Tokenize:`${G.toFixed(1)} ms`,Total:`${m.toFixed(1)} ms`})}const oe={utterance_text:Oe,words:ee,tokens:fe,confidence_scores:o?{token:de.map(m=>+m.toFixed(4)),token_avg:+Je?.toFixed(4),word:ee.map(m=>m.confidence),word_avg:+qe?.toFixed(4),frame:he.map(m=>+m.toFixed(4)),frame_avg:he.length?+(he.reduce((m,_)=>m+_,0)/he.length).toFixed(4):null,overall_log_prob:+Le.toFixed(6)}:{overall_log_prob:null,frame:null,frame_avg:null},metrics:w?{preprocess_ms:+C.toFixed(1),encode_ms:+y.toFixed(1),decode_ms:+X.toFixed(1),tokenize_ms:+G.toFixed(1),total_ms:+(performance.now()-F).toFixed(1),rtf:+(J/((performance.now()-F)/1e3)).toFixed(2),preprocessor_backend:se,mel_cache:v?.cached?{cached_frames:v.cachedFrames,new_frames:v.newFrames}:null}:null,is_final:!A&&!f};return u&&(oe.decoderState=this._snapshotDecoderState(E)),p&&(oe.tokenIds=N.slice()),g&&(oe.frameIndices=xe.slice()),b&&(oe.logProbs=Se.map(m=>+m.toFixed(6))),T&&(oe.tdtSteps=Pe.slice()),this._disposeDecoderState(E),oe}createStreamingTranscriber(e={}){return new rt(this,e)}endProfiling(){try{this.encoderSession?.endProfiling()}catch{}try{this.joinerSession?.endProfiling()}catch{}const e=this.ort?.env?.wasm?.FS;if(!e)return console.warn("[Parakeet] Profiling FS not accessible"),null;const s=e.readdir("/tmp").filter(n=>n.startsWith("profile_")&&n.endsWith(".json"));if(!s.length)return console.warn("[Parakeet] No profiling files found. Was profiling enabled?"),null;const t={};for(const n of s)try{const o=e.readFile("/tmp/"+n,{encoding:"utf8"}),r=JSON.parse(o);let i=0,h=0;for(const d of r)if(d.cat==="Node"){const l=d.args?.provider;l==="webgpu"?i+=d.dur:l&&(h+=d.dur)}t[n]={gpu_us:i,cpu_us:h,total_us:i+h}}catch(o){console.warn("[Parakeet] Failed to parse profile file",n,o)}return console.table(t),t}}class rt{constructor(e,s={}){this.model=e,this.opts={returnTimestamps:s.returnTimestamps??!0,returnConfidences:s.returnConfidences??!1,returnTokenIds:s.returnTokenIds??!1,sampleRate:s.sampleRate??16e3,debug:s.debug??!1},this._decoderState=null,this._currentOffset=0,this._totalWords=[],this._totalTokenIds=[],this._chunkCount=0,this._isFinalized=!1}async processChunk(e){if(this._isFinalized)throw new Error("Streamer is finalized. Create a new instance to process more audio.");const s=e.length/this.opts.sampleRate,t=await this.model.transcribe(e,this.opts.sampleRate,{returnTimestamps:this.opts.returnTimestamps,returnConfidences:this.opts.returnConfidences,returnTokenIds:this.opts.returnTokenIds,previousDecoderState:this._decoderState,returnDecoderState:!0,timeOffset:this._currentOffset});return this._decoderState=t.decoderState,this._currentOffset+=s,this._chunkCount++,t.words&&t.words.length>0&&this._totalWords.push(...t.words),this.opts.returnTokenIds&&t.tokenIds&&this._totalTokenIds.push(...t.tokenIds),this.opts.debug&&console.log(`[Streamer] Chunk ${this._chunkCount}: "${t.utterance_text}" (${t.words?.length||0} words, offset: ${this._currentOffset.toFixed(2)}s)`),{chunkText:t.utterance_text,chunkWords:t.words||[],text:this._totalWords.map(n=>n.text).join(" "),words:this._totalWords.slice(),totalDuration:this._currentOffset,chunkCount:this._chunkCount,is_final:!1,...this.opts.returnTokenIds?{tokenIds:this._totalTokenIds.slice()}:{},...this.opts.returnConfidences&&t.confidence_scores?{confidence_scores:t.confidence_scores}:{},metrics:t.metrics}}finalize(){return this._isFinalized=!0,{text:this._totalWords.map(e=>e.text).join(" "),words:this._totalWords.slice(),totalDuration:this._currentOffset,chunkCount:this._chunkCount,is_final:!0,...this.opts.returnTokenIds?{tokenIds:this._totalTokenIds.slice()}:{}}}reset(){this._decoderState=null,this._currentOffset=0,this._totalWords=[],this._totalTokenIds=[],this._chunkCount=0,this._isFinalized=!1}getState(){return{hasDecoderState:this._decoderState!==null,currentOffset:this._currentOffset,wordCount:this._totalWords.length,chunkCount:this._chunkCount,isFinalized:this._isFinalized}}}class ut{constructor(e={}){this.frameTimeStride=e.frameTimeStride||.08,this.timeTolerance=e.timeTolerance||.2,this.stabilityThreshold=e.stabilityThreshold||2,this.confirmedTokens=[],this.pendingTokens=[],this.stabilityMap=new Map}_tokenKey(e,s){const t=Math.round(s*10);return`${e}@${t}`}processChunk(e,s,t=0){if(!e.tokenIds||!e.frameIndices)throw new Error("FrameAlignedMerger requires tokenIds and frameIndices");const n=e.tokenIds.map((d,l)=>({id:d,frameIndex:e.frameIndices[l],absTime:s+e.frameIndices[l]*this.frameTimeStride,logProb:e.logProbs?.[l]??0,text:e.tokens?.[l]?.token||""})),o=s+t,r=n.filter(d=>d.absTime<o),i=n.filter(d=>d.absTime>=o),h=this._findAnchors(r);if(h.length>0){const d=h[0].absTime,l=this.pendingTokens.filter(f=>f.absTime<d);this.confirmedTokens.push(...l);for(const f of r){const u=this._tokenKey(f.id,f.absTime),c=(this.stabilityMap.get(u)||0)+1;this.stabilityMap.set(u,c),c>=this.stabilityThreshold&&(this.confirmedTokens.some(g=>Math.abs(g.absTime-f.absTime)<this.timeTolerance&&g.id===f.id)||this.confirmedTokens.push(f))}}return this.pendingTokens=i,{confirmed:this.confirmedTokens.slice(),pending:this.pendingTokens.slice(),anchorsFound:h.length,totalTokens:this.confirmedTokens.length+this.pendingTokens.length}}_findAnchors(e){const s=[];for(const t of e)for(const n of this.pendingTokens)if(t.id===n.id&&Math.abs(t.absTime-n.absTime)<this.timeTolerance){s.push(t);break}return s.sort((t,n)=>t.absTime-n.absTime)}getText(e){const s=[...this.confirmedTokens,...this.pendingTokens];s.sort((n,o)=>n.absTime-o.absTime);const t=s.map(n=>n.id);return e.decode(t)}getAllTokens(){return[...this.confirmedTokens,...this.pendingTokens].sort((s,t)=>s.absTime-t.absTime)}reset(){this.confirmedTokens=[],this.pendingTokens=[],this.stabilityMap.clear()}getState(){return{confirmedCount:this.confirmedTokens.length,pendingCount:this.pendingTokens.length,stabilityMapSize:this.stabilityMap.size}}}class mt{constructor(e={}){this.frameTimeStride=e.frameTimeStride||.08,this.timeTolerance=e.timeTolerance||.15,this.K=e.sequenceAnchorLength||3,this.vignetteSigmaFactor=e.vignetteSigmaFactor||.25,this.confirmedTokens=[],this.pendingTokens=[],this._lcsBuffer=new Int32Array(1024)}processChunk(e,s,t=0){if(!e.tokenIds||!e.frameIndices)throw new Error("LCSPTFAMerger requires tokenIds and frameIndices");const n=e.tokenIds.length,o=e.tokenIds.map((g,b)=>({id:g,frameIndex:e.frameIndices[b],absTime:s+e.frameIndices[b]*this.frameTimeStride,logProb:e.logProbs?.[b]??0,text:e.tokens?.[b]?.token||"",vignetteWeight:this._computeVignette(b,n)})),r=s+t,i=o.filter(g=>g.absTime<r),h=o.filter(g=>g.absTime>=r);if(this.pendingTokens.length===0)return this.pendingTokens=o,{confirmed:this.confirmedTokens.slice(),pending:this.pendingTokens.slice(),lcsLength:0,anchorValid:!1,isFirstChunk:!0};const d=this.pendingTokens.map(g=>g.id),l=i.map(g=>g.id),[f,u,c]=this._lcsSubstring(d,l);let p=!1;if(c>=this.K&&(p=this._verifyFrameAlignment(this.pendingTokens.slice(f,f+c),i.slice(u,u+c))),p){const g=f+c;this.confirmedTokens.push(...this.pendingTokens.slice(0,g))}else if(c>0){const g=this.pendingTokens.slice(f,f+c),b=i.slice(u,u+c),T=this._arbitrateByLogProb(g,b);this.confirmedTokens.push(...this.pendingTokens.slice(0,f)),this.confirmedTokens.push(...T)}else this.confirmedTokens.push(...this.pendingTokens);return this.pendingTokens=h,{confirmed:this.confirmedTokens.slice(),pending:this.pendingTokens.slice(),lcsLength:c,anchorValid:p,overlapTokenCount:i.length}}_lcsSubstring(e,s){const t=e.length,n=s.length;if(t===0||n===0)return[0,0,0];this._lcsBuffer.length<n+1&&(this._lcsBuffer=new Int32Array(n+1+1024));const o=this._lcsBuffer;o.fill(0,0,n+1);let r=0,i=0,h=0;for(let f=1;f<=t;f++){let u=0;for(let c=1;c<=n;c++){const p=o[c];e[f-1]===s[c-1]?(o[c]=u+1,o[c]>r&&(r=o[c],i=f,h=c)):o[c]=0,u=p}}const d=i-r,l=h-r;return[d,l,r]}_verifyFrameAlignment(e,s){if(e.length!==s.length)return!1;for(let t=0;t<e.length;t++)if(Math.abs(e[t].absTime-s[t].absTime)>this.timeTolerance)return!1;return!0}_arbitrateByLogProb(e,s){if(!(e.some(r=>r.logProb!==0)||s.some(r=>r.logProb!==0)))return e;const n=e.reduce((r,i)=>r+i.logProb*i.vignetteWeight,0),o=s.reduce((r,i)=>r+i.logProb*i.vignetteWeight,0);return n>=o?e:s}_computeVignette(e,s){if(s<=1)return 1;const t=(s-1)/2,n=s*this.vignetteSigmaFactor;return Math.exp(-Math.pow(e-t,2)/(2*n*n))}getText(e){const s=this.confirmedTokens.map(n=>n.id),t=this.pendingTokens.map(n=>n.id);return{confirmed:e.decode(s),pending:e.decode(t),full:e.decode([...s,...t])}}getAllTokens(){return[...this.confirmedTokens,...this.pendingTokens].sort((e,s)=>e.absTime-s.absTime)}reset(){this.confirmedTokens=[],this.pendingTokens=[]}getState(){return{confirmedCount:this.confirmedTokens.length,pendingCount:this.pendingTokens.length,lastConfirmedTime:this.confirmedTokens.length>0?this.confirmedTokens[this.confirmedTokens.length-1].absTime:0,lastPendingTime:this.pendingTokens.length>0?this.pendingTokens[this.pendingTokens.length-1].absTime:0}}}const it={en:"English",fr:"French",de:"German",es:"Spanish",it:"Italian",pt:"Portuguese",nl:"Dutch",pl:"Polish",ru:"Russian",uk:"Ukrainian",ja:"Japanese",ko:"Korean",zh:"Chinese"},ae={"parakeet-tdt-0.6b-v2":{repoId:"ysdede/parakeet-tdt-0.6b-v2-onnx",displayName:"Parakeet TDT 0.6B v2 (English)",languages:["en"],defaultLanguage:"en",vocabSize:1025,featuresSize:128,preprocessor:"nemo128",subsampling:8,predHidden:640,predLayers:2},"parakeet-tdt-0.6b-v3":{repoId:"istupakov/parakeet-tdt-0.6b-v3-onnx",displayName:"Parakeet TDT 0.6B v3 (Multilingual)",languages:["en","fr","de","es","it","pt","nl","pl","ru","uk","ja","ko","zh"],defaultLanguage:"en",vocabSize:4097,featuresSize:128,preprocessor:"nemo128",subsampling:8,predHidden:640,predLayers:2}},pt="parakeet-tdt-0.6b-v2";function He(a){if(ae[a])return ae[a];for(const[e,s]of Object.entries(ae))if(s.repoId===a)return s;return null}function gt(a){for(const[e,s]of Object.entries(ae))if(s.repoId===a)return e;return null}function wt(a,e){const s=He(a);return s?s.languages.includes(e.toLowerCase()):!1}function kt(){return Object.keys(ae)}function bt(a){return it[a.toLowerCase()]||a}const at="parakeet-cache-db",ce="file-store";let Ce=null;const _e=new Map;async function ct(a,e="main"){const s=`${a}@${e}`;if(_e.has(s))return _e.get(s);const t=`https://huggingface.co/api/models/${a}?revision=${e}`;try{const n=await fetch(t);if(!n.ok)throw new Error(`Failed to list repo files: ${n.status}`);const r=(await n.json()).siblings?.map(i=>i.rfilename)||[];return _e.set(s,r),r}catch(n){return console.warn("[Hub] Could not fetch repo file list – falling back to optimistic fetch",n),_e.set(s,[]),[]}}function Xe(){return Ce||(Ce=new Promise((a,e)=>{const s=indexedDB.open(at,1);s.onerror=()=>e("Error opening IndexedDB"),s.onsuccess=()=>a(s.result),s.onupgradeneeded=t=>{const n=t.target.result;n.objectStoreNames.contains(ce)||n.createObjectStore(ce)}})),Ce}async function lt(a){const e=await Xe();return new Promise((s,t)=>{const r=e.transaction([ce],"readonly").objectStore(ce).get(a);r.onerror=()=>t("Error reading from DB"),r.onsuccess=()=>s(r.result)})}async function dt(a,e){const s=await Xe();return new Promise((t,n)=>{const i=s.transaction([ce],"readwrite").objectStore(ce).put(e,a);i.onerror=()=>n("Error writing to DB"),i.onsuccess=()=>t(i.result)})}async function Ke(a,e,s={}){const{revision:t="main",subfolder:n="",progress:o}=s,r="https://huggingface.co",i=[a,"resolve",t];n&&i.push(n),i.push(e);const h=`${r}/${i.join("/")}`,d=`hf-${a}-${t}-${n}-${e}`;if(typeof indexedDB<"u")try{const T=await lt(d);if(T)return console.log(`[Hub] Using cached ${e} from IndexedDB`),URL.createObjectURL(T)}catch(T){console.warn("[Hub] IndexedDB cache check failed:",T)}console.log(`[Hub] Downloading ${e} from ${a}...`);const l=await fetch(h);if(!l.ok)throw new Error(`Failed to download ${e}: ${l.status} ${l.statusText}`);const f=l.headers.get("content-length"),u=f?parseInt(f):0;let c=0;const p=l.body.getReader(),g=[];for(;;){const{done:T,value:k}=await p.read();if(T)break;g.push(k),c+=k.length,o&&u>0&&o({loaded:c,total:u,file:e})}const b=new Blob(g,{type:l.headers.get("content-type")||"application/octet-stream"});if(typeof indexedDB<"u")try{await dt(d,b),console.log(`[Hub] Cached ${e} in IndexedDB`)}catch(T){console.warn("[Hub] Failed to cache in IndexedDB:",T)}return URL.createObjectURL(b)}async function _t(a,e,s={}){const t=await Ke(a,e,s),o=await(await fetch(t)).text();return URL.revokeObjectURL(t),o}async function ht(a,e={}){const s=He(a),t=s?.repoId||a,n=s?.preprocessor||"nemo128",{encoderQuant:o="int8",decoderQuant:r="int8",preprocessor:i=n,preprocessorBackend:h="js",backend:d="webgpu",progress:l}=e;let f=o,u=r;d.startsWith("webgpu")&&f==="int8"&&(console.warn("[Hub] Forcing encoder to fp32 on WebGPU (int8 unsupported)"),f="fp32");const c=f==="int8"?".int8.onnx":".onnx",p=u==="int8"?".int8.onnx":".onnx",g=`encoder-model${c}`,b=`decoder_joint-model${p}`,T=await ct(t,e.revision||"main"),k=[{key:"encoderUrl",name:g},{key:"decoderUrl",name:b},{key:"tokenizerUrl",name:"vocab.txt"}];h!=="js"?(k.push({key:"preprocessorUrl",name:`${i}.onnx`}),console.log(`[Hub] Preprocessor: ONNX — will download ${i}.onnx`)):console.log(`[Hub] Preprocessor: JS (mel.js) — skipping ${i}.onnx download`),T.includes(`${g}.data`)&&k.push({key:"encoderDataUrl",name:`${g}.data`}),T.includes(`${b}.data`)&&k.push({key:"decoderDataUrl",name:`${b}.data`});const S={urls:{},filenames:{encoder:g,decoder:b},quantisation:{encoder:f,decoder:u},modelConfig:s||null,preprocessorBackend:h};for(const{key:w,name:F}of k)try{const C=l?y=>l({...y,file:F}):void 0;S.urls[w]=await Ke(t,F,{...e,progress:C})}catch(C){if(w.endsWith("DataUrl"))console.warn(`[Hub] Optional external data file not found: ${F}. This is expected if the model is small.`),S.urls[w]=null;else throw C}return S}async function Tt(a){return ye.fromUrls(a)}async function Ft(a,e={}){const s=ae[a]?.repoId||a,t=await ht(s,e);return ye.fromUrls({...t.urls,filenames:t.filenames,preprocessorBackend:t.preprocessorBackend,...e})}export{pt as DEFAULT_MODEL,ut as FrameAlignedMerger,Ee as IncrementalMelProcessor,ie as JsPreprocessor,it as LANGUAGE_NAMES,mt as LCSPTFAMerger,ft as MEL_CONSTANTS,ae as MODELS,ye as ParakeetModel,rt as StatefulStreamingTranscriber,tt as createMelFilterbank,st as createPaddedHannWindow,ot as fft,Ft as fromHub,Tt as fromUrls,bt as getLanguageName,He as getModelConfig,Ke as getModelFile,gt as getModelKeyFromRepoId,_t as getModelText,ht as getParakeetModel,Ne as hzToMel,kt as listModels,et as melToHz,nt as precomputeTwiddles,wt as supportsLanguage};
